<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Scala To C Overview]]></title>
    <url>%2F2018%2F12%2F20%2F2018%2FscalaToC%2Foverview%2F</url>
    <content type="text"><![CDATA[基本语法 变量定义 函数定义 条件表达式 循环表达式 运算符 函数集合指针IO]]></content>
      <categories>
        <category>ScalaToC</category>
      </categories>
      <tags>
        <tag>会使用</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala To C Plus Plus Overview]]></title>
    <url>%2F2018%2F12%2F20%2F2018%2FscalaToCPP%2Foverview%2F</url>
    <content type="text"><![CDATA[基本语法 变量定义 函数定义 条件表达式 循环表达式 运算符 面向对象 封装、继承、多态 对象初始化过程 集合 可变集合 List Set Map 不可变集合 … 常用的操作 多线程 线程定义和运行 线程交互(锁、Actor) 函数式 Lambda 表达式 函数作为参数传递 内存回收元编程 反射 宏 IO FileRead and FileWrite Network 创建工程 如何在工程中引入其它的第三方类库 如何编程內库并上传到中心仓库]]></content>
      <categories>
        <category>ScalaToCPP</category>
      </categories>
      <tags>
        <tag>会使用</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala 高等类型——二维泛型]]></title>
    <url>%2F2018%2F10%2F23%2F2018%2F10%2Fscala-Highter-kind-type%2F</url>
    <content type="text"><![CDATA[Java ArrayList&lt;T&gt; 的一个设计缺陷在 Java 中，ArrayList是我们常用的一个容器，它有一个方法，subList(int fromIndex, int toIndex) 可以获取到一个该 list 的一个子序列。我们可以使用如下的代码来测试它：12345678@Testpublic void subListSpec() &#123; ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;(); a.add(1); a.add(2); ArrayList&lt;Integer&gt; r = (ArrayList&lt;Integer&gt;) a.subList(0, 1); assertEquals(r, new ArrayList&lt;Integer&gt;().add(2));&#125; 然后我们运行上述代码，竟然会报错了(JDK 版本为1.8，操作系统为 Ubuntu 16.04):1java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList 其实上面的代码在设计层面就有一点小问题： 对于ArrayList&lt;A&gt;来说，它的subList方法返回的竟然是List&lt;A&gt;类型。 这个让人感觉到有点诧异，一个对象的subValue难道不应该是自身类型吗？ 就像String对象调用substring(b,e)方法返回的应该是String对象本身的类型。 让我们把上面的问题放大一些，当我们在设计一个接口的时候，我们该如何确定返回值类型呢？让我们来设计一个简单的容器：Container，如果按照Java的编程思想，你可能会这么设计接口：12345public interface Container&lt;T&gt; &#123; public Container&lt;T&gt; put(T t); public T get(Container&lt;T&gt; c);&#125; 而子类，或许你会这么设计：1234567891011public class MyList2&lt;T&gt; implements Container&lt;T&gt; &#123; public Container&lt;T&gt; put(T t) &#123; return null; &#125; public T get(Container&lt;T&gt; c) &#123; return null; &#125;&#125; 上面的代码看上去很不错，但是它有一个问题：MyList2的put方法返回值竟然是Container类型，这会给使用者造成很大的疑惑，甚至有时候会造成类型转换异常。 一个更合理的设计方案产生上面问题的原因是我们在父类(接口)中过早的定义了方法的返回值类型，当子类去实现的时候，使用父类的返回类型作为返回类型，而这种实现方式在某些场景下是不合理的。 我们来尝试一种理论上更合理的实现方式，先不考虑使用哪种语言来实现。 既然错误的原因是由于父类过早的写死了返回值的类型，那我们能不能传递一个子类类型的泛型给父类，当不同的子类实现的时候，返回值会根据子类传递给父类的泛型来确定。 此时这个泛型已经不仅仅是一个简单的泛型T，它是一个表示泛型类的泛型，例如它可以表示List&lt;T&gt;,我们暂时使用[_]来表示这个泛型，那上面Container的例子就可以进入如下的改写：123456// 这里的M可以看做是一个泛型的变量，它代表一个泛型类的类型，例如List[A]public interface Container&lt;M [_]&gt; &#123; // 这是一个泛型方法，其中A是泛型，返回值是 M[A] 代表着某个泛型类，如List[A] public &lt;A&gt; M[A] put(A t); // 这是一个泛型方法，其中 A 是泛型，参数是 M[A] 代表着某个泛型类，如List[A] public &lt;A&gt; A get(M[A] c); 那么子类就可以很轻松的实现：12345678910// 把 MyList2[A] 作为泛型传递给父类public class MyList2&lt;A&gt; implements Container&lt;MyList2&gt; &#123; // 此时返回值类型理所应当就是List[A] public &lt;A&gt; MyList2&lt;A&gt; put(A t) &#123; return null; &#125; // 此时参数类型理所应当就是List[A] public &lt;A&gt; A get(MyList2&lt;A&gt; c) &#123; return null; &#125; 通过这种把子类当做泛型传递给父类的操作，我们就可以在定义父类(接口)的时候，灵活的使用参数和返回类型，不幸的是，Java似乎不支持这种语法！ 但是Scala支持这种语法，而且这种特性在Scala中被称作高等类型(Higher-kinded types) 使用 Scala 高等类型来完成 Container1234567891011121314151617181920212223242526272829303132import org.scalatest.FlatSpecclass ScalaHigherKindedSpec extends FlatSpec &#123; // 定义一个Container trait，它拥有一个高等类型 trait Container[M[_]] &#123; def put[A](a: A): M[A] def get[A](a: M[A]): A &#125; // 把 List[A] 作为类型传递给 Container case object MyList extends Container[List] &#123; def put[A](a: A): List[A] = List(a) def get[A](a: List[A]): A = a.head &#125; // 把 Some[A] 作为类型传递给 Container case object MySome extends Container[Some] &#123; def put[A](a: A): Some[A] = Some(a) def get[A](a: Some[A]): A = a.get &#125; // 测试 "test MyList" should "succeed" in &#123; val ml = MyList.put(1) assert(MyList.get(ml) == 1) &#125; "test MySome" should "succeed" in &#123; val ms = MySome.put(2) assert(MySome.get(ms) == 2) &#125;&#125; 小结到此，我们可以发现Scala的高等类型是一种比泛型更加抽象的泛型，我们可以把它理解为二维的泛型，它表示的是一个带泛型的类型参数，定义为trait Container[M[_]]，如果你希望子类可以进行逆变或者协变，你可以使用这样的定义：trait Container[M[+ _]]trait Container[M[- _]]]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>会使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScalaProp Usage Guide]]></title>
    <url>%2F2018%2F10%2F14%2F2018%2F10%2FScalaProp%2F</url>
    <content type="text"><![CDATA[Scala-tes-prop provides test cases generator then run test function with them. Finally it will println test result information and return a boolean value to tell you test result which can be asserted by scala test. Now, let’t see how to use it! GeneratorGenerator is basic component in scala-test-prop, which can generate test cases you want. For example, if you want to get a range integer, you see following code:1234import prop.gen.Gen// return a Gen[Int] with integer range in (1,10), but the range exclusive 10Gen.choose(1, 10) It also can generate other generator, such as Gen.odd(10,100), Gen.listOf(10, Gen.choose(10,100)). The first function will return random odd integer from 10 to 100, but inclusive 100. The second function will return a list with 10 size whoseelements range is between 10 and 100 but exclusive 100. You can find more in Object Gen ExecutorNow, you have knew how to obtain a generator, but how to run testing function with them? The Executor match to Gen is Prop. Prop is running parameters to testing result container. You can do &amp;&amp; or || with two Prop, the implement you can refer: https://github.com/KnewHow/ScalaProp/blob/master/src/main/scala/prop/Prop.scala You can call Prop.test(n,rng) to get test result. The first parameter is how many test cases will be taken to test. The second parameter is random number generator. You can get it by RNG.get. We have provided some default value to make you use it eaisily. If you want to test a sorted function, you can generate a Gen[List[A]] first, then test it by Prop, you can refer following code:123456789101112131415161718package test.prop.genimport org.scalatest.FlatSpecimport prop.gen._class ListOfFixedSizeSpec extends FlatSpec &#123; "test listOf with fixed size" should "success" in &#123; // Generate list with 20 size whose element is between 10 and 100 val g = Gen.listOfN(20, Gen.choose(10, 100)) val p = Prop.forAll(g) &#123; r =&gt; // Writing what you want to test, make sure it last result is boolean. val s = r.sorted val h = s.headOption h.map(rs =&gt; !r.exists(_ &lt; rs)).getOrElse(true) &#125; // In default, test function will run checked function with 10 test cases. assert(p.test()) &#125;&#125; Because test function return a boolean value, if the value is true, representing the all test cases passed, you can combine it with scala-test assert. At same time, Prop.test also println some test information in console. If all test cases passed, it will print [info] OK, 10 testcases passed, otherwise will print [error] test case failure, case by...,But success n times. you can also generate a list with random size by Gen.listOfN(Gen.choose(10, 20), Gen.choose(10, 100)). Incremental TestingSometimes, once or twice testing don’t test whether a bug in checked function. We may want a test way, which can increase the test cases gradually until run enough times we assigned. SProp is born in time! For example, If you want to test a sorted function and want to test it 20 times with test cases increasing gradually. You can choose SProp, you can refer following code:12345678910111213141516171819202122232425262728293031package test.prop.sgenimport org.scalatest.FlatSpecimport prop.gen._class SPropFixedStepSpec extends FlatSpec &#123; "test SProp with sorted function by fixed step increasing" should "success" in &#123; // geneate a list with random size whose element is random val g = Gen.listOfN(Gen.choose(100, 200), Gen.choose(300, 400)) // conver Gen into SGen, it is very simply val sg = g.unsized // similar with Prop.forAll, just return a boolean result val p = SProp.forAll(sg) &#123; r =&gt; val s = r.sorted val h = s.headOption h.map(rs =&gt; !r.exists(_ &lt; rs)).getOrElse(true) &#125; // run the checked function assert( p.test( // the minimal test cases will be run first minTestCase = 10, // the step the test cases will increase by step = 1, // how many time the function will be run testTimes = 20, // whether use random step randomStep = false )) &#125;&#125; The function will take 10 test cases first, then increase test cases by step 1 unitl it run 20 times. In this way, it will reduce testing fortuity. But sometimes, fixed step could be stiff, So we also prepare a random step between 1 and n which you assigned. You just needassign randomStep=true, we will genereate random step between 1 and n We has give some default parameters to test function, So you can not pass any parameters to test function. BugsThe Gen is so easy and elegant, but it has some bugs:If you want to test Gen.listOfN with a big size list, it will throw stack overflow. The tempoary solution is you can increase stack size by jvm prameters with -Xss500M. You can write it in a file named .jvmopts in sbt project root directory. I will try to fix it in the future! How to GetYou can add following code in your build.sbt file to get it:12// https://mvnrepository.com/artifact/com.github.knewhow/scalaproplibraryDependencies += "com.github.knewhow" %% "scalaprop" % "1.0" Touch MeThe project Github address is: https://github.com/KnewHow/ScalaProp, If you has some problems about it or you hava a better solution, you could touch me by email for help or give issues. Thank you!]]></content>
      <categories>
        <category>指导手册</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>会使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin Type? VS Scala Option]]></title>
    <url>%2F2018%2F06%2F20%2F2018%2F06%2FTypeVSOptional%2F</url>
    <content type="text"><![CDATA[最近阅读一些关于 Kotlin 类型系统方面的书，发现 Kotlin 的类型系统针对 null 有着独特的设计哲学。在 Java 或者其它编程语言中，经常会出现 NullPointerException，而导致此异常的重要原因是因为你可以写 String s = null 这样的代码。其实可以认为这是 Java 等语言类型系统设计的一个缺陷，它们允许 null 可以作为任何类型的值！ 但是在 Kotlin 中，如果你声明 val s: String = null，那么编译器会给你一个 error，因为在 Kotlin 中，你不允许把一个 null 值赋给一个普通的类型。如果你声明一个这样的函数 fun strLen(s: String) = {...}，那么这个函数将不接受值为 null 的参数。 这个设计看起来如此的美好，他可以极大程度的减少 Kotlin 产生 NullPointerException，可是如果有一天，你需要调用一个方法，它的返回值可能为 null 也可能为 String ，那么在 Kotlin 中你可以声明一个可空的字符串类型：String?。val s: String? = null 此时 Kotlin 的编译器会让这行代码通过。当然它也可以接收一个普通的 String 类型的值 val s: String? = &quot;abc&quot;。 可空类型(Type?)的设计，是 Kotlin 另一个设计哲学，它要求工程师在设计的时候就需要确定该变量是否可为空。如果不为空就使用Type 类型声明，否则就使用 Type? 类型声明。这让我想起在 Scala 中存在一个和 Type? 有着异曲同工之妙的一个类型—— Option[T]。 Option[T] 有两个子类型：Some[T] 和 None，你可以使用 val s: Option[String] = Some(&quot;123&quot;) 来表示一个字符串存在，当然你可以使用val s: Option[String] = None 来表示这个字符串不存在。 Scala 和 Kotlin 都是基于 JVM 的编程语言，而 Option[T] 和 Type? 的设计就是用来解决 JVM 平台出现的 NullPointerException。但二者的设计理念却截然不同，Scala 的 Option[T] 是在原有类型基础上使用 Option 做一层封装，而 Koltin 的 Type? 是使用语法糖完成的。 那么这两种设计方案到底谁更好一点呢？我们将会使用以下标准来分别测试它们： 是否可以完美的规避 NullPointerException —— 二者的设计都是为了解决 NullPointerException，谁可以更好的规避这个问题呢？ 代码的可读性 —— 如果在复杂的业务中，谁的代码可读性更好一点呢？ 性能 规避空指针在上文中，我们曾经提过，NullPointerException 产生的原因是你可以把一个 null 的值传递给一个类型的变量，然后调用这个类型的方法。我们可以使用 Java 的代码来表示一下：String s = null; s.length()。 在 Type? 的设计理念中，对于不确定是否为 null 类型可以使用 Type? 类型来声明，如val s: String? = getString...，此时 s 的类型是 String?，你不能直接调用 s.length，你需要进行安全调用s?.length。这个函数的返回类型是一个 Int?，这很正常，对于一个不确定是否为 null 的类型进行安全调用返回当然是一个 Type? 类型。如果 s 不为 null 正常返回 s 的长度，否则返回 null。除此之外， Kotlin 还针对 Type? 提供了 Elvis 操作和 let 函数，具体的用法可以参考 Kotlin 官方手册。 而在 Optional 的设计哲学中，你可以使用 Option[T] 来包裹一个不确定是否为 null 的值。这里我们使用 Scala 的代码来演示：val s: Option[String] = Option(getString...)，此时 s 的类型为 Option[String]，你仍然不能直接调用s.length，你可以使用 map 函数：s.map(s =&gt; s.length)，它的返回值是一个 Option[Int] 类型。和 Type? 很类似，对一个 Option[T] 类型使用 map 函数，结果当然是一个 Option[S] 类型。在 Scala 中，你也可以使用模式匹配来处理 Option 类型。 总结：二者都可以完美的规避 NullPointerException，Type? 使用安全调用来避免直接调用 Type 类型的方法，而 Option 则使用 map 函数或者模式匹配来处理。本质上都是避免直接调用值可能为 null 的类型变量的方法。 代码可读性实际的业务是比较复杂的，例如，我们需要计算两个数字字符串的乘积，首先我们需要把他们转换为 Int 类型，如果其中一个字符串是转换失败，则无法计算结果。 在 Kotlin 的 Type? 中，我们需要重新定义 String 类型的 toInt 方法，让它返回一个 Int? 类型，代码如下：12345fun tryString2Int(a: String) = try &#123; a.toInt()&#125;catch (e:Exception)&#123; null&#125; 然后我们需要定义一个方法来计算两个数字字符串的乘积，这里我们使用 Type? 的 let 函数，它接受一个 Lambda 表达式，如果调用者的值不为 null，则调用 Lambda 表达式，否则直接返回 null。strNumberMuti 函数返回的是一个 Double? 类型，如果有任何一个字符串转换数字失败，就返回 null，都转换成功才计算乘积。1234fun strNumberMuti(s1: String, s2: String): Double? = tryString2Int(s1)?.let&#123; a -&gt; tryString2Int(s2)?.let &#123; t -&gt; a * t * 1.0 &#125;&#125; 这段代码的可读取有点差呀，而且在实际的业务开发过程中，可能会有更多的 Type? 类型，那代码岂不是要爆炸了！。幸运的是，Kotlin 允许我们使用 if 来代替 let 函数 做相同的判断，代码如下：12345fun strNumberMuti2(s1: String, s2: String):Double? &#123; val a = tryString2Int(s1) val b = tryString2Int(s2) return if(a!=null &amp;&amp; b!= null) a * b * 1.0 else null&#125; 这样的代码可读性就好多了，但是丢失函数式的编程美感。而且感觉 Type? 是一种语法糖，手动对 Type? 进行非空校验，就可以直接使用 Type 类型了！！ 同样的我们使用 Scala 的 Option[T] 来完成上面的需求，为了让 toInt 函数返回 Option[T] 类型，我们定义了一个 Try 函数，这个函数看不懂没关系，你只需知道它接受一个函数，并且返回一个 Option[A] 值即可。代码让如下：1234def Try[A](a: =&gt; A): Option[A] = &#123; try Some(a) catch &#123;case e: Exception =&gt; None&#125; &#125; 同样的，我们需要写一个函数，用来把两个字符串数字转换为整数，并且做它们的乘积，这里我们为了使代码更简洁，使用了 Scala 的 for 推导，具体的用法可以参考 Scala 官方的 Document。strNumberNu返回类型是 Option[Double]，如果有任何一个转换失败，返回 None，否则返回 Some[Double]，代码如下： 1234567def strNumberMuti(s1: String, s2: String): Option[Double] = &#123; for&#123; a &lt;- Try&#123; s1.toInt &#125; b &lt;- Try&#123; s2.toInt &#125; &#125; yield a * b &#125; 可以看出，使用 Scala 的 Option[T] 更具有函数式的编程美感，而且代码的可读性极强，而且即使有更多的 Option[T]，for 推导都可以轻松应对。 总结：面对比较复杂的业务场景，Type? 和 Option[T] 都可以轻松应对，但是 Type? 的用法就显得有些 low，还是使用 !=null 的套路，这也暴露了它的设计是存在缺陷的。相反的 Option[T] 的设计理念是完备的，而且极具函数式的编程美感。 性能性能是衡量设计好坏的一个重要的方面，下面我们只做一个简单的测试：让两个字符串都是&quot;999&quot;，然后分别执行 Kotlin 的 strNumberMuti 和 Scala 的 strNumberMuti 一千万次，然后我们发现 Kotlin 的 strNumberMuti 执行时间大约在 1.9s，而 Scala 的 strNumberMuti 执行时间约在 5.0s。由此可以看出，Kotlin 的 Type? 比 Scala Option[T] 拥有更好的性能，其实这样很正常，因为 Kotlin 的 Type? 是语法糖，创建一个 Type? 的对象其实和创建一个 Type 的对象其实消耗的性能差不多，但是 Option[T]不仅仅需要创建 T 类型的对象，更需要创建 Option[T] 类型的对象来包裹 T 类型的对象，因此它的开销大一点。 总结就我而言，我更喜欢 Scala 的 Option[T] 的设计，因为它是理论完备的，而且极具函数式的编程美感，即使它的性能要差一点。对于 Kotlin 的 Type? 类型，我觉得它的设计有瑕疵，就拿 let 函数举例，在单个 Type? 很好用，但是当多个 Type? 进行组合的时候，就显得很鸡肋。 萝卜青菜，各有所爱，也许某天 Kotlin 也会让 Type? 具有函数式的编程美感。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端工程师入门前端页面重构（二）：心法 II]]></title>
    <url>%2F2018%2F03%2F24%2F2018%2F03%2Fback-2-front-xinfa-2%2F</url>
    <content type="text"><![CDATA[上一篇博客，我们介绍了前端页面重构应遵循的第一个心法－「清除浮动」，那么这篇我们就来聊聊第二个心法－「语义化」 Web 应用的交互性如果你在百度或者谷歌的输入框中输入「Scala」并且按下回车，那么百度或者谷歌就会给你展示很多条和「Scala」相关的搜索结果，那么百度是如何知道这些 Web 应用是和「Scala」相关的呢？不仅仅是搜索引擎，分类信息网和网络爬虫等其它搜集 Web 应用信息的应用也需要这样的功能。此外对于 Web 应用的搭建者，他们更希望其它 Web 应用可以获取自己的 Web 应用信息，甚至精确到每个页面，这样它们的应用才能得到推广。 因此在当今 Web 应用迅速的发展时期，不仅仅要在用户和 Web 应用之间搭建沟通的桥梁，Web 应用之间同样需要“沟通交流”。 那么如何实现不同 Web 应用之间的交流呢？ 语义化第一种实现方式是让 Web 应用(尤其是搜索引擎)往人工智能方向发展，让 Web 应用尽可能智能化。这种实现方式的成本有点高，并且还得依赖于人工智能的发展，而且不是所有的 Web 应用都能拥有搜索引擎背后那雄厚的资源。 第二种实现方式是让我们的代码更加语义化。我们最终展现给用户看到的是通过 CSS 渲染和添加了 JS 事件的 HTML，但是对于网页内容描述的只有 HTML 代码，而且搜索引擎最终读取的也是 HTML 代码 。 因此在我们设计 Web 应用的时候，必须要回到内容本身，将内容本身的语义合理地表述出来，而不考虑它最终呈现给用户的是什么样子。 那我们如何通过 HTML 将内容本身的语义合理的表达出来呢？ 精确的表达你想描述的内容这是一个「是什么」的概念，你描述的内容到底是什么？一段视频？一段文字？需要通过对应的 HTML 标签来精确的表达这些内容。 例如你想表示这是一篇文章，那么你需要使用「article」标签，如果你想表示文章的标题或者子标题，那么你应该使用「hx」标签，如果你想表示这是文章中的一幅图片，你应该使用「img」标签，如果你想给文章加上页眉和页脚，那么你需要使用「header」和「footer」标签…… 总之，对内容本意描述的越精确越好。 但是我们知道，主流的页面布局使用的是 DIV+CSS 的方式，「div」表达是是一个区块，它是一个抽象的概念，并没有的具体的语义。那么如何用它们来表达语义呢？ 我们可以给「div」添加 id 或者 class 属性来增强它的语义，虽然这种语义和上面的相比有点弱，但是还是可以被识别的，而且它们是表达并列关系语义的一种较好的方式。 处理好层级关系「关系」在页面布局中是一个重要的概念，而且 HTML 的嵌套本身就表达一种包含关系。 例如，在一篇文章中，文章的内容都是文章这个概念的子集，段落中或许有图片。 因此我们需要使用「article」标签来包含所有的文章内容，在 「p」中嵌入「img」。 就像这样： 1234567&lt;article&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; &lt;img/&gt; &lt;/p&gt; ...&lt;/article&gt; 当然，我们也可以通过 class 来增强它们的语义。但是如果父元素的 class 已经表示某些内容，那么子元素的 class 不需要重复的去表示。 如父元素为&lt;article class=&quot;acticle&quot;&gt;&lt;/article&gt;，那么子元素使用&lt;h1 class=&quot;h1&quot;&gt;&lt;/h1&gt; 即可，使用&lt;h1 class=&quot;acticle-h1&quot;&gt;&lt;/h1&gt;反而显得赘余。 除了包含关系，并列关系在页面布局中也很常见。文章中段落是并列的关系，我们使用 p 标签来表达它们的语义，可以使用 class 属性来增强它们属于同一个「类别」。 123&lt;p class="paragraph"&gt;&lt;/p&gt;&lt;p class="paragraph"&gt;&lt;/p&gt;&lt;p class="paragraph"&gt;&lt;/p&gt; 资源的语义化上面的两种方法，都是针对具体的代码来实现语义化，可是对于整个 Web 应用而言，资源的划分是以 URL 为最小单位的，因此 URL 的语义化，会让搜索引擎可以更好的把握 Web 应用的功能，迅速的定位到具体的功能页面。 URL 的设计应能展现 Web 应用的资源结构，下面的 URL 就很好的展现了 dripower 不同的「解决方案」：123https://weixin.drip.im/solution/crmhttps://weixin.drip.im/solution/paymenthttps://weixin.drip.im/solution/marketing 而且 URL 应该被纯粹的表达。如下面的例子：12https://weixin.drip.im/index.php/solution/crmhttps://weixin.drip.im/solution/crm 虽然两个 URL 都能访问，但是明显第二个 URL 更好些，因为它更纯粹，更是技术无关性的。 「心法篇」到这里就介绍完了，可是对于页面布局中的各种疑难杂症该如何解决呢？请大家继续关注这个系列的「招式篇」。 知乎Understanding Semantic Web and Ontologies]]></content>
      <categories>
        <category>前端页面重构系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 Java 到 Scala（一）：面向对象谈起]]></title>
    <url>%2F2018%2F02%2F10%2F2018%2F02%2FForm-Java2Scala-1-oop%2F</url>
    <content type="text"><![CDATA[去年我加入水滴团队，面试中，面试官问：“你了解 Scala 吗？” “不了解(尴尬)。” “你知道 Spark 吗？它就是使用 Scala 编写的，不过在我们团队中，Scala 主要作为后端语言，我们 90% 以上的业务代码都是使用 Scala 编写。Scala 在国内使用的比较少，但是在国外用的还是蛮多的，如 Twitter 就是使用 Scala 写的后端。” 自那以后，我便开始了 Scala 的学习之旅。 Scala 是由德国的计算机科学家和编程方法教授 Martin Odersky 设计出来的，它的设计原理严格遵循数学的逻辑推理。因此它是一门优秀的编程语言，它不仅仅在工业界被广泛使用，在学术界也占用很高的研究地位。 由于之前的 Java 背景，我经常拿 Scala 与 Java 这两门语言比较。 Scala 和 Java 都基于 JVM，因此 Java 的类库，Scala 都可以直接使用。但是我对 Scala 印象最深的点，并不是「面向对象」，而是它还拥抱「函数式」，尤其是它的「高阶」。 如果我们把「面向对象」比作站在地面上观察事物的原理，并且使用这些原理解决问题，那么「高阶」就是让你站在山上去看待事物，对问题进行更高层次的抽象。 因此不管是解决实际问题，还是提高对编程语言的认知，Scala 都是一们值得学习的语言。 我是从《快学 Scala》这本书开始学习 Scala 的，受此书启发，我想能不能书写一个「从 Java 到 Scala 系列」，寻找一棵从 Java 通往 Scala 的连续的知识树，通过对知识树的讲解，来学习 Scala。 好了，这就是本系列的第一篇，那么我们如何谈起呢？ 既然 Java 和 Scala 都是「面向对象」的，那我们就来探索一下什么是「面向对象」吧。 模板和对象「模板」是在代码层面描述一类对象的「行为」或者「状态」的代码，它是抽象的。如 Java 中的类，C 语言中的结构体，它们都是「模板」。 「对象」是在运行期间通过模板在内存中生成的一个个实体，它是具体的。如 Java 在运行期间通过 new 在内存中产生的实体就叫做「对象」。 如果你说共享单车，那么它就是一个「模板」；如果你说这辆共享单车和那辆共享单车，那它们就是「对象」。 在代码层面，「对象」的行为可以定义为「方法」，「对象」的状态可以定义为「属性」，那我们如何去描述一类「对象」的方法或者属性呢？－封装。 例如共享单车，它有车轮，二维码等属性，有开锁和关锁等行为。那么我们可以有三种方式来封装共享单车。 基于对象的封装这种方式就是直接封装，最典型的例子就是 C 语言中的结构体。封装共享单车的「模板」如下： 123456struct SharedBicycle&#123; 车轮; 二维码; 开锁; 关锁;&#125;; 基于类的封装大多数「面向对象」的语言，如 Java，Scala，C++等，都使用这种方式封装，「模板」如下：123456class SharedBicycle&#123; 属性：车轮; 属性：二维码; 方法：开锁; 方法：关锁;&#125; 基于原型的封装JavaScript 就是使用这种封装方式，「模板」如下：1234567function SharedBicycle()&#123; this.车轮 = xxx; this.二维码 = xxx;&#125;//添加原型方法SharedBicycle.prototype.开锁 = function()&#123;...&#125;;SharedBicycle.prototype.关锁 = function()&#123;...&#125;; 纯面向对象我们已经得知，可以用多种实现面向对象的不同技术，那么什么是纯面向对象的语言呢？ 我们知道 Java 是一门「面向对象」的语言，那么在 Java 中是否真的「万物皆对象」？ 在 Java 中，我们可以写这么一段代码 int a = 3; 然后我们发现 a 并没有封装任何的属性或者方法。 因此我们可以说 a 不是一个「对象」，Java 不是一门「纯粹面向对象」的语言。 再看看 Scala ，不论是低阶的 Int，Double，还是高阶类型，都封装有属性或者方法，因此 Scala 才是一门「纯粹面向对象」的语言。 那么是什么支持 Scala 一切皆为「对象」的呢？－Scala 的通用类型系统。 Scala 通用类型系统顶类型我们知道，在 Java 中，所有「对象」的「顶类型」都是 java.lang.Object，但是 Java 却忽略了 int，double等 JVM 「原始类型」,它们并没有继承 java.lang.Object。 但是在 Scala 中，存在一个通用的「顶类型」－ Any。 Scala 引入了Any 作为所有类型共同的顶类型。Any 是 AnyRef 和 AnyVal 的超类。 AnyRef 面向 Java（JVM）的对象世界，它对应 java.lang.Object ，是所有对象的超类。 AnyVal 则代表了 Java 的值世界，例如 int 以及其它 JVM 原始类型。 正是依赖这种继承设计，我们才能够使用 Any 定义方法，同时兼容 scala.int 以及 java.lang.String 的实例。 123456789class Personval allThings = ArrayBuffer[Any]()val myInt = 42 // Int, kept as low-level `int` during runtimeallThings += myInt // Int (extends AnyVal)allThings += new Person() // Person (extends AnyRef), no magic here 正是通过这种「通用类型系统」的设计，使得 Scala 摆脱「原始类型」这种边缘情况的纠缠，从而实现「纯粹的面向对象」。 说完了「顶类型」，我们再来看看「底类型」。 底类型我们知道在 Java 中比较闹心的就是异常处理，当我们调用一个抛出异常的方法，我们必须抛出或者处理异常。 但是在 Scala 中，我们知道一切表达式皆有类型，难道「抛异常」也是有类型的？ 12scala&gt; val a = Try(throw new Exception("123"))a: scala.util.Try[Nothing] = Failure(java.lang.Exception: 123) 我们发现「抛异常」竟然是 Nothing 类型，在 Scala 中，难道 Nothing 仅仅是作为「抛异常」的类型？ 12345678scala&gt; def fun(flag:Boolean)=&#123; if(flag)&#123; 1 // Int &#125;else&#123; throw new Exception("123") //Nothing &#125; &#125;fun: (flag: Boolean)Int 我们发现 fun 函数并没有报错，而且返回值类型竟然是 Int，这让我们有一个大胆的猜测：Nothing 是 Int 的子类型。 12[Int] -&gt; ... -&gt; AnyVal -&gt; AnyNothing -&gt; [Int] -&gt; ... -&gt; AnyVal -&gt; Any 其实在 Scala 中， Nothing 不仅仅是 Int 的子类型，它更是所有类型的子类型。 这让我们又产生了一个大胆的猜测：难道 Nothing 继承了所有的类型？咳咳，这个问题我们以后在讨论。 在 Scala 中，还有一个类型 Null 遵循着和 Nothing 一样的原理。 12345678scala&gt; def fun2(flag:Boolean)=&#123; if(flag)&#123; "123" //String &#125;else&#123; null //Null &#125; &#125;fun2: (flag: Boolean)String 同理，我们可以得出 Null 是 String的子类型12[String] -&gt; AnyRef -&gt; AnyNull -&gt; [String] -&gt; AnyRef -&gt; Any 那我们看看 Null 是否可以兼容 Int。12345678scala&gt; def fun3(flag:Boolean)=&#123; if(flag)&#123; 123 //Int &#125;else&#123; null //Null &#125; &#125;fun3: (flag: Boolean)Any 我们发现 fun3 的返回值类型竟然是 Any，说明 Null 不能兼容 Scala 的「值类型」，其实从 Scala 的帮助手册中我们就可以得出结论：Null 继承了AnyRef，因此 Null 是所有引用类型的子类型。 1abstract final class Null extends AnyRef 正因如此，fun3 的返回值类型才是 Any，因为 Any 才是 AnyVal 和 AnyRef 公共的超类。 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 总结=======「通用类型系统」我们就先介绍到这里，下面我们小结一下。 小结1.模板是封装属性或者方法的一种抽象。2.对象是具有属性或者方法的一种实体。3.封装的方式有三种：基于对象、基于类、基于原型。4.「面向对象」是一种设计程序的方式，它要求工程师以对象为最小单位设计程序。5.「纯粹面向对象」要求一切变量皆为对象，Scala 是，Java 不是。6.Scala 的「顶类型」是 Any，它有两个直接的子类型：AnyRef 面向 JVM 对象的世界，AnyVal 面向 JVM 值的世界。7.Scala 有两个「底类型 」，Nothing 所有类型的底类型，Null 所有引用类型的底类型。6.「通用类型系统」的设计使得 Scala 摆脱 JVM 原始类型的纠缠，从而实现「纯粹面向对象」。 a51c6619bb7b02ebf128c63cc9a28b20a4f015ce 本文以面向对象为引子，找到了一个 Java 和 Scala 共有的知识节点，从而引出 Scala 的通用类型系统。那么在下一篇文章中，我们由此展开进一步思考，到底什么是所谓的「类型」，以及 Scala 在类型方面存在哪些与 Java 不同的有趣的地方。 Scala 类型的类型（一）。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java2Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端工程师入门前端页面重构（二）：心法 I]]></title>
    <url>%2F2018%2F01%2F05%2F2017%2F12%2Fback-2-font-xinfa-1%2F</url>
    <content type="text"><![CDATA[上一篇博客是我们《后端工程师入门前端页面重构》系列的第一篇，我们介绍了页面布局的口诀： 从左到右，从上到下，化整为零。 那么在接下来的几篇文章中，我们就来聊聊页面布局的「心法」和一些具体的「招式」。 那么什么是心法呢？ 如果说口诀是页面布局的原则，那么心法就是对页面布局中一些重要概念的认识。 在上一篇文章，我们一直推荐使用高效的浮动布局，类似大家都玩过的磁铁，在磁铁的周围，所有的铁块会被磁铁所吸引。 那么浮动就好比页面上的一块磁铁，它会吸引页面上的元素块，让它们朝一个方向进行组合、包含、交叠，进而完成整个页面的布局。 下面就让我们来看看页面中元素有什么类型。 HTML 块状元素和行内元素在我们熟知的页面布局中，网页的标题，logo等都是有高度和宽度的。我们来看下面的豆瓣首页的切图： 在上面的图片中，我们使用红色的线条和文字标注豆瓣 logo 的高度和宽度。不仅仅是 logo 图有高度和宽度，搜索框，热搜主题等其它元素，几乎都有高度和宽度。 那么在 HTML 语言中，我们如何指定元素的高度和宽度呢？ 我们先来写一段 HTML： 12&lt;div&gt;这是 div 标签里面的内容&lt;/div&gt;&lt;span&gt;这是 span 标签的内容&lt;/span&gt; 然后给它们定义样式： 123456789div &#123; background-color: red; height: 100px; width: 100px;&#125;span &#123; background-color: green; height: 100px; width: 100px; 效果如下： 发现一个问题： 我们设置的高度和宽度只对 div 标签产生效果，对 span 标签没有产生效果。这是为什么呢？ 其实在 HTML 中，我们可以把标签分为「块状元素」和「行内元素」，上面代码中的 div 标签就是块状元素，而 span 标签就是行内元素。 那么这两类元素有什么区别呢？ 从我们的代码的效果图里面我们已经看出来一个区别了：块状元素可以设置它的高度和宽度，行内元素对的高度和宽度的设置是无效。 我们把上面元素的宽度和高度都删除，让 div 标签和 span 标签保持原始的高度和宽度来看看效果。 是不是又看出来一个区别呢？ 块状元素是独占一行的，而行内元素只占本身内容的大小。 看看我们之前设置高度和宽度的例子，我们用浏览器检查一下看看。 即使我们设置了块状元素的高度和宽度，它还是独占一行的。真的是霸道啊！ 然而，现实中的网页（如豆瓣），很多内容块都是拼接的，如果我们使用块状元素来表示这些内容块，如果消除它独占一行的情况呢？ 关于这个问题，似乎有两种解决方案。 inline-block其实在 css 的 diplay 属性中，有一个属性值 inline-block 可以将标签呈现出「块状元素」和「行内元素」之间的中间态，即它可以拥有宽高度的同时，也可以具备行内元素的占位属性。 12&lt;div&gt;123&lt;/div&gt;&lt;div&gt;123&lt;/div&gt; 然后给它们定义样式： 1234div &#123; background-color: red; display: inline-block;&#125; 看效果： 我们发现虽然两个 div 可以变成行内元素在一行显示，但是它们之间还是存在空白，不能完美的相邻在一起。这点空白会让我们的布局很不美观！ 浮动上面我们说了，浮动可以把页面上的元素往某一个方向吸引，那么如何吸引呢？在 CSS 中，我们可以通过 float:left 把元素往左边吸引 12&lt;div style="background-color: red"&gt;这是第一个区块&lt;/div&gt;&lt;div style="background-color: green"&gt;这是第二个区块&lt;/div&gt; 使用浮动： 12345div &#123; width: 200px; height: 200px; float: left;&#125; 看效果： 我们发现，通过浮动，可以使两个原本很难相邻在一起的块状元素，完美 的相邻在一起。 使用 left 是把元素往左边吸引，而 right 是把元素往右边吸引。 那么当浮动和元素嵌套结合会发生什么呢？ 父元素高度在页面布局中，元素嵌套使用是非常常见的，如下面的代码。12345&lt;div class="parent"&gt; &lt;div class="child1"&gt; first child &lt;/div&gt;&lt;/div&gt; 123.child1 &#123; background-color: red;&#125; 此时，子元素的高度是自适应的，也就是当前浏览器显示的文字高度，如果对页面进行缩放，子元素高度就会变化。 而父元素包含着子元素，而且父元素里面没有其它元素，因此父元素的高度等于子元素的高度。 我们也可以使用 height来设置子元素的高度，让它不自适应。 在实际开发中，经常需要使用一个父元素嵌套一些浮动元素，现在我们就来设置子元素为浮动元素。 12345.child1 &#123; background-color: red; float: left; height: 100px;&#125; 我们发现父元素的高度竟然变成了０。 我们尝试再添加一个非浮动的子元素时，我们发现，父元素的高度等于第二个非浮动子元素的高度，完全忽视了第一个浮动子元素的存在。 123&lt;div class="child2"&gt; second child&lt;/div&gt; 1234.child2 &#123; background-color: green; height: 50px;&#125; 而当我们把第二个子元素设置为浮动的时候，父元素的高度又再度变成了０。 按照上面的方法，添加第三个元素的时候，效果也是相同的。 通过上面的例子，我们可以得出一个结论：父元素的高度由最后一个非浮动子元素的占位空间所决定。 但是在页面布局中，浮动布局的占位空间往往是我们理想的容器父元素的高度，那么我们如何解决这个问题呢？ 清除浮动使用清除浮动就可以解决上面的问题，具体的做法是在父元素的最后添加一个空的元素，并在设置它为清除浮动。 12&lt;div class="child3"&gt;&lt;/div&gt; 123.child3 &#123; clear: left;&#125; 我们发现父元素的高度等于浮动元素的占位空间。 clear: left; 就是让左浮动元素持有占位空间 让我们再来拓展一下，clear 除了可以设置为 left，还可以设置为 right 和 both。 right 就是让右浮动元素持有占位空间。 both 就是让两边的浮动元素都持有占位空间。 浮动布局–最佳实践在上面的代码中，我们是直接手动的在父元素最后添加空元素。那么能不能有一种方法，可以自动的帮我们添加元素并在设置清除浮动呢？ 回答是肯定的！ 在 CSS 中，我们可以使用 「after 选择器」 来实现添加元素，并且设置属性，具体的用法可以参考:W3C after 选择器 下面直接给出代码： .clearfix:after { content: " "; display: block; clear: both; height: 0; } .clearfix { zoom: 1; } 在IE6, 7下 zoom: 1 会触发 hasLayout，从而使元素闭合内部的浮动。 在标准浏览器下，.clearfix:after 这个伪类会在应用到 .clearfix 的元素后面插入一个 clear: both 的块级元素，从而达到清除浮动的作用。 只要父元素引用了这个 class，就可以自动的实现清除浮动，再也不用担心高度和子元素的占位问题了。 心法小结最后，我们再来回顾一下文章介绍的一些心法： 1. HTML 分为块状元素和行内元素的，块状元素是独占一行的 2. 浮动布局相对行内元素的布局，往往更利于精确计算间距 3. 默认情况下，父元素的高度由最后一个非浮动子元素的占位空间所决定 4. 浮动布局的占位空间往往是我们理想的容器父元素的高度 5. 清除浮动可以解决浮动元素的占位空间问题 文章中的一些招式可能说的太粗糙，先不用捉急，我们先学心法，招式到后面再专门的学习。 我会在下一篇博文继续介绍心法 II。]]></content>
      <categories>
        <category>前端页面重构系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端工程师入门前端页面重构（一）：口诀]]></title>
    <url>%2F2017%2F12%2F15%2F2017%2F12%2Fback-2-font-koujue%2F</url>
    <content type="text"><![CDATA[大家好，我是 KnewHow，一名前 Java 开发工程师。为什么要说是「前」呢？这要从两周前我加入一家新公司说起。 入职第一天，实习导师告诉我会有一个月的新人引导计划，当时心里还是美滋滋的，觉得这个公司比较人性化，没有把工程师当劳动力使。 但随后，我就被震撼到了。因为面试时就得知公司崇尚的是全栈文化，在部署完一切办公环境之后，实习导师告诉我开始学习的第一个技能竟然是：「前端页面重构」！！！ 当时我的内心是这样子的。 要知道，我对于前端，除了几个基本的标签外，可是一无所知。然而，我很快调整了状态，不就是前端开发么，应该难不倒机智的我。 —————————— 以下开始严肃脸 ————————— 什么是页面重构好，第一个问题：那么什么是所谓的「页面重构」呢？ 实习导师提出了要求，一定要有自己深刻的见解，好吧。。。。。 于是，我的视线离开了电脑屏幕，开始寻求不一样的答案。很快，我注意到了我的办公桌面，是这样子滴。 在我看来，前端页面重构，本质不就是处理空间布局的关系吗？ 于是，机智如我，很快得出了自己的见解和答案。 上面的这张图片是日常生活一个场景: 一张办公桌上面摆放着一些物品。桌面是背景，书和键盘并排的放着，白色书和紫色书交叠着，紫色书上面放着一个鼠标。 其实这就是一个布局，也类似一张网页。 然后我看了看旁边同事的桌子，也看了看整个公司的办公环境。 然后我发现在一个布局中，存在三种关系:组成，包含和交叠。 于是，我把这个结论告诉了实习导师。实习导师听后思考许久，但还是表达了赞赏。之后，他又提出了第二个问题： 那么，你说说看什么是「盒子模型」？ 这一次，我马上 Google 了这个概念。机智如我，基于我以上的结论，很快我又得出了以下的解读。 盒子模型在我看来，「盒子模型」, 本质就是去解决布局中位置和距离的关系 在上面的桌面场景中,键盘和紫色书是并排放着的，他们之间的距离可以使用「盒子模型」中的「外边距(margin)」来表示。 鼠标被紫色书包含着，他们之间的距离可以使用「内边距(padding)」来表示。 白色书和紫色书他们是交叠在一起的，他们同样可以使用「外边距(margin)」来表示，只不过值要是负数。 我找到了实习导师，把我刚刚总结的答案告诉了他，他微微一笑,说：这个回答还算不错，接着又问道: 那么在网页布局中，「盒子模型」是怎么被使用的呢? 当时我的内心是这样的： 你怎么这么多问题，你特么还有完没完!!! 理智的我压制了自己的小情绪，不就是怎么使用「盒子模型」吗？谷歌在手，天下我有!! 绝对定位布局机智的我很快就有了答案，这也太简单了！ 我们只要把网页划分成一个个小块，然后调整他们的位置就行了。 拿豆瓣的首页来说吧,我们可以把第一行分为三块，分别为豆瓣的logo,搜索框和后面的热搜主题。 然后我们只需要使用「外边距(margin)」来设置他们和浏览器左边界之间的距离，就ＯＫ了。 哈哈，我简直就是个天才。 我把我的答案告诉了实习导师。心里美滋滋的：“你们招我进来，是不亏的！！” 实习导师轻瞟了一眼我的答案，预料中的赞美和肯定并没有出现。 他目光转向我，说：“你的这种方案是可行的，但是只有入门级别的小白才会使用。而且这种设计方案是低效的”！ 绝对定位布局 －－ 低效分析“啊，低效的？为什么是低效的？” “在网页中，会有成百上千的元素，如果每个元素你都去量一下他的边距，这个效率是不是很低！” “好像是这样的” “最近我在研究移动端开发，移动端对绝对定位布局有一个更清晰的描述：” “绝对定位本质就是通过帧来定位一个视图的起点，高度和宽度。” “这个就要求你需要去计算每个视图的位置和大小。” “更可怕的是，如果有一天有一个元素的位置或者大小发生改变，那么你需要去修改所有的受影响的元素,这个更是低效的！” “简单来说 就是牵一发而动全身！” “好像有那么几分道理，导师，你怎么这么厉害啊” “低调低调，我可是切了十年页面的男人！！” “现在的页面布局都使用 「浮动布局」，你去调研一下吧” “嗯(亲昵)” 浮动布局我用 Google 搜索了浮动布局和绝对定位布局。机智的我发现了他们最本质的一个区别： 绝对定位布局使用浏览器的窗口的边界作为参考，一个元素的位置是针对浏览器的边界来设定的。 而且在绝对定位布局中，元素和元素之间视对方为不存在，这意味着当一个元素位置和大小发生了变化，不会对其他元素产生影响。 而在浮动布局中，他们的位置可以用其他的元素作为参考系。 如果有一天被参考的元素位置或者大小发生了变化，那么当前元素的位置也会发生相应的变化。这样就比较高效了。 我兴奋的把调研结果告诉了实习导师，实习导师看了后，说:“还可以吧，” 接着他又问道，“如果现在给你一个网页，你知道怎么布局吗？” “这个。。。” 页面重构之口诀“看你这个犹犹豫豫的样子，我直接告诉你好了” “我们在网页的左上方放一块磁铁，那么所有元素都会被磁铁所吸引，那么磁力相反的方向，就是我们布局的方向” “所以我们布局的方向就是从左到右，从上到下” “明白了吗？” “还不是很明白” “那我们来做个练习吧” “看这个豆瓣的首页，先从整体来看，按照从左到右可以分成几个部分？” “一个部分吧”“对的”“因为整个页面就只有中间的那个部分” “从上到下，你看看这个页面可以分成几个部分？” “这个好像有点多了，每一行都可以分成一个部分吧” “不错嘛，看你你已经掌握了规律,看看下面的可以分成几个部分” “这个。。。” “不要捉急，安装我的口诀，先看从左到右分成几个部分，再看从上到下分成几个部分” “从左到右可以分成三个部分” “从上到下就一个部分吧，感觉没有其他东西了” “不错不错，我们再来一个难一点的,看看这个可以分成几个部分” “从左到右可以分成三个部分” “从上到下可以分成一个部分” “那这个呢?” “从左到右一个部分，从上到下也是一个部分” “这个呢?” “从左到右一个部分，从上到下三个部分” “这个呢?” “从左到右一个部分，从上到下四个部分” “这个呢” “从左到右两个部分，从上到下一个部分” “有没有发现什么规律？” “就是按从左到右，从上到下的顺序，先把网页的进行整体的划分，然后在依次对小模块进行划分，然后再对更小的模块进行划分，一直这么递归划分下去” “好的!你已经学会了” “啊！这么简单的？那个可以问你一个问题？能不能先从上到下，在从左到右？” “不能，因为人看网页的习惯就是先从左到右，在从上到下，这样的设计会有更好的视觉效果” 这边文章只是介绍页面的重构的「口诀」，我们将在下一篇介绍「心法」。]]></content>
      <categories>
        <category>前端页面重构系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
